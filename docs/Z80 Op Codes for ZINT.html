
<!-- saved from url=(0031)http://www.z80.info/z80code.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Z80 Op Codes for ZINT</title>
<meta name="title" content="Thomas Scherrer Z80-Family HomePage">
<meta name="keywords" content="Z80,Z180,Z280,Z380,Programming,Hardware,Software,Utilities,FAQ,Support,CPU,assembler,emulators,simulators">
<meta name="description" content="Z80, Z180, Z280, Z380, Programming, Hardware, Software, Utilities, FAQ, Support, CPU, assembler">
<style>@media print {#ghostery-purple-box {display:none !important}}</style></head><body bgcolor="#FFFFFF">
<a href="http://www.z80.info/z80_home.htm">
<img src="./Z80 Op Codes for ZINT_files/zlogo1.gif" alt="Z80 Home" height="98" width="198" border="0"></a><p>

By <a href="http://www.geocities.com/SiliconValley/Horizon/2252/index.html">
James Moxham</a>

</p><pre> ZINT Z80 INTERPRETER

                     Copyright 1996 James Moxham


Chapter 1                LD group of instructions
Chapter 2                Exchange group
Chapter 3                The stack, POP and PUSH
Chapter 4                Arithmetic
Chapter 5                Jumps calls and returns
Chapter 6                And or and xor
Chapter 7                Bit set reset and test
Chapter 8                Rotate and shift
Chapter 9                General arithmetic and control
Chapter 10               Block transfer and search
Chapter 11               Input and Output instructions
Chapter 12               Additional useful commands
Chapter 13               Number bases
Chapter 14               The flags

Appendix 1               Binary, hex ascii decimal TC conversion

*****************************************************************

                  CHAPTER 1 The LD instruction


     The LD instruction is perhaps the most useful instruction in
the Z80.  It is used to transfer data between registers,  and  to
and  from  memory.  The most simple type of LD instruction is  to
fill a register with a number: (Use F1)

LD A,6

     This loads the A register with the number 6, so the register
display now appears as

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
06 000000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

     You can transfer this data to other registers

LD H,A

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
06 000000 0000 0000 0600 0000 0000 00 000000 0000 0000 0000 0000

copies  the data in the A register to the H register.  In fact  H
could  have been any one of A B C D E H or L.  The data in the  A
register remaines unchanged.

                 Transferring data: Number bases

     As  most  programmers  of BASIC will  know  numbers  can  be
represented in several forms,  binary octal and hexadecimal being
common bases. The registers in the above example display the data
in hexadecimal form. Thus

LD A,255 gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
FF 000000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

     FF  is  255 in hexadecimal.  The equivalent statement  using
hexadecimal directly is

LD A,0FFH

     The H at the end signifies that the number is a hex  number.
The  0  at the front is necessary because the first digit in  any
number should always be between 0 and 9.

     You can also use binary

LD A,11111111B

     where  the  B at the end specifies the number  is  a  binary
number.

     The  reason  for  using  all three  bases  is  because  some
instructions  are much easier to understand in one base.

Two other bases are supported,  two's complement and direct ascii
characters  and  are discussed in detail in ch16.  The  following
instructions all do the same thing.

LD B,073H
LD B,01110011B
LD B,65
LD B,"s"

                      Double register LD's

     As you notice from the register display some registers  have
been  grouped  together.  For example the H and L  registers  are
displayed  together as HL.  You can treat these pairs as if  they
were one

LD HL,1000 returns

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000000 0000 0000 03E8 0000 0000 00 000000 0000 0000 0000 0000

We  can alse transfer this data from one double register pair  to
another

LD BC,HL gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000000 03E8 0000 03E8 0000 0000 00 000000 0000 0000 0000 0000

     The double registers can be any one of BC DE HL IX IY or SP.

                  Transfers to and from memory

     The   above  instructions  all  transfer  data  within   the
microprocessor.  The  following sequence transfers a data to  the
memory (Use F1 or write as a program and then type F5)

LD A,255:LD HL,1000:LD,(HL) A

     Here  we  are using more than one statement in a  line.  The
first  two statements load the registers as we have seen  before.
The  last  statement  loads memory location  1000  with  255.  To
retrieve this data we can use

LD D,(HL)

which transfers 255 from the memory to register D.

To see what is in the memory at any one time use the view
memory command.

In  general  the  memory  location is usually  given  by  the  HL
register  pair.  The BC and DE regsters can be used as the memory
location  but  the  data  can only be  transferred  to  and  from
register A eg LD (BC),A is allowed but LD B,(DE) is not.

A  second  way to transfer data to and from memory is  to  use  a
number instead of a register pair. Thus

LD E,(38C1H) transfers to register E the data in memory 1000
LD (HL),34 transfers to the location stored in HL the no 34

A third way is to use the IX and IY registers. Say for example we
want  to store the word HELLO in memory.  First we would look  up
the  ASCII values for the letters,  which are 72 69 76 76 79.  We
will  store the word starting at memory location  500.  First  we
load IX or IY with 500

LD IX,500

Next the data is transferred

LD (IX),72:LD (IX+1),69:LD (IX+2),76:LD (IX+3),76:LD (IX+4),79

Use the view memory command to see where this data is.

The  final way LD can be used is to transfer double registers  to
and from memory. For example

LD (500),BC

transfers  the contents of C to the memory location 500  and  the
contents of B to location 501.  We can load this data from memory
to register pair DE with a

LD DE,(500)

The  register can be BC DE HL IX  IY  or  SP.

What  follows now is a list of all the possible  LD  instructions
sorted alphabetically.  The letter n is used to indicate a number
between 0 and 255 (0 and 0FFH).  nn represents a number between 0
and  65535 (0 and 0FFFFH).  d is any number between -128 and +127
(the +d can be -d; LD (IX-23) A

LD (BC),A       LD B,(HL)       LD H,(IX+d)
LD (DE),A       LD B,(IX+d)     LD H,(IY+d)
LD (HL),A       LD B,(IY+d)     LD H,A
LD (HL),B       LD B,A          LD H,B
LD (HL),C       LD B,B          LD H,C
LD (HL),D       LD B,C          LD H,D
LD (HL),E       LD B,D          LD H,E
LD (HL),H       LD B,E          LD H,H
LD (HL),L       LD B,H          LD H,L
LD (HL),n       LD B,L          LD H,n
LD (IX+d),A     LD B,n          LD HL,(nn)
LD (IX+d),B     LD BC,(nn)      LD HL,nn
LD (IX+d),C     LD BC,nn        LD I,A
LD (IX+d),D     LD C,(HL)       LD IX,(nn)
LD (IX+d),E     LD C,(IX+d)     LD IX,nn
LD (IX+d),H     LD C,(IY+d)     LD IY,(nn)
LD (IX+d),L     LD C,A          LD IY,nn
LD (IX+d),n     LD C,B          LD L,(HL)
LD (IY+d),A     LD C,C          LD L,(IX+d)
LD (IY+d),B     LD C,D          LD L,(IY+d)
LD (IY+d),C     LD C,E          LD L,A
LD (IY+d),D     LD C,H          LD L,B
LD (IY+d),E     LD C,L          LD L,C
LD (IY+d),H     LD C,n          LD L,D
LD (IY+d),L     LD D,(HL)       LD L,E
LD (IY+d),n     LD D,(IX+d)     LD L,H
LD (nn),A       LD D,(IY+d)     LD L,L
LD (nn),BC      LD D,A          LD L,n
LD (nn),DE      LD D,B          LD R,A
LD (nn),HL      LD D,C          LD SP,(nn)
LD (nn),IX      LD D,D          LD SP,HL
LD (nn),IY      LD D,E          LD SP,IX
LD (nn),SP      LD D,H          LD SP,IY
LD A,(BC)       LD D,L          LD SP,nn
LD A,(DE)       LD D,n
LD A,(HL)       LD DE,(nn)
LD A,(IX+d)     LD DE,nn
LD A,(IY+d)     LD E,(HL)
LD A,(nn)       LD E,(IX+d)
LD A,A          LD E,(IY+d)
LD A,B          LD E,A
LD A,C          LD E,B
LD A,D          LD E,C
LD A,E          LD E,D
LD A,H          LD E,E
LD A,L          LD E,H
LD A,n          LD E,L
LD A,R          LD E,n
LD A,I          LD H,(HL)

****************************************************************

                  CHAPTER 2 The EX instructions

     In  addition  to the registers we have mentioned so far  the
Z80 has several additional registers. The most important of these
are  the so called prime registers,  which are designated A'  BC'
DE' and HL'.  You cannot access these registers directly, but you
can  swap them with the ordinary registers.  If you type  in  the
following code

LD BC,1234H:LD DE,5678H:LD HL,9ABCH  the registers will appear

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000000 1234 5678 9ABC 0000 0000 00 000000 0000 0000 0000 0000

Now type in

EXX       which swaps BC DE and HL with the prime registers

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000000 0000 0000 0000 0000 0000 00 000000 1234 5678 9ABC 0000

You can now work on the normal registers, eg

LD BC,1111H

When you want to swap the registers back again use EXX

The  EXX  statement is very useful for storing variables you  are
working on without having to save them in memory.  The equivalent
store  to  memory  for  these three registers  would  take  3  LD
statements.

Other EX commands

Several other commands exist that swap registers.

EX AF,AF'

swaps  the A register and the flags with the corresponding  prime
registers. It is commonly used with EXX.

EX DE,HL

swaps the DE register and the HL register.

EX (SP),HL
EX (SP),IX
EX (SP),IY

all  swap the memory contents pointed to by the SP register  with
the  corresponding register.  The equivalent code for EX
(SP),HL could be

LD HL,1234H:LD BC,5678H:LD (1000H),BC:LD SP,1000H  then
LD BC,(1000H):LD (1000H),HL:LD HL,BC

Thus in the case of EX (SP),HL the L register is swapped with the
data  at the memory location pointed to by the SP  register,  and
the H register is swapped with the memory location + 1 pointed to
by the SP register. Type MEMORY to check this.

Exchange Commands

EXX                           EX (SP),HL
EX AF,AF'                     EX (SP),IX
EX DE,HL                      EX (SP),IY

****************************************************************

                      Chapter 3 The Stack

     The  memory  of a computer can be thought of as  a  library,
with  each  book representing a memory location.  LD BC,(350)  is
like finding the 350th book.  The stack on the other hand is like
a  pile of books.  Instead of storing the BC register  in  memory
location 350 and then retrieving it later we can put it on top of
a pile of books, and take it off later.

     The following code shows how the stack works

LD BC,1234:LD SP,504H initialises the registers

PUSH BC     takes the BC register and puts it on top of the  pile
of books.

LD BC,0  clears the BC register, and

POP BC    takes the top book and puts it back in the BC register.

If  you now view the memory you can see what has happened. The SP
register was used as a pointer as to where the top of the pile of
books  was.  Thus  after  PUSH  BC,  503H contains 12  or  the  H
register,  and 502 contains 34 or the L register. The SP was 502.
POP  BC put 502 into the L register and 503 into the H  register,
and added 2 to SP to make 504 again.

     In fact the data in 502 and 503 could have been POP ed  into
any register. Try the dollowing to confirm this

PUSH BC:POP DE

Because  memory locations are used to store data you have to  set
where  you  wnat the stack to be before using PUSH and  POP.  The
stack  was  in  this  case set at 504 but  could  have  been  any
location.  The instruction LD SP,504 should occur before any PUSH
or  POP  instructions  are used and so usually appears  near  the
beginning of a program.  Most programs would use a maximum of  20
PUSH's before POP's so you need to make sure that about 40 memory
locations below the initial value of the SP are not used. The ORG
instruction is used to reserve this memory.

The  PUSH and POP instruction both work on double register  pairs
only.  Thus  for the purposes of this instruction the A  register
and  the  flag register are grouped together as an  AF  register,
with the F register being the least significant byte. The way the
individual  flags are grouped in the F register is  discussed  in
the chapter on the flags.





The stack commands

PUSH AF                  POP AF
PUSH BC                  POP BC
PUSH DE                  POP DE
PUSH HL                  POP HL
PUSH IX                  POP IX
PUSH IY                  POP IY

******************************************************************

                      Chapter 4 Arithmetic

     Arithmetic   in  machine  code  is  a  little  different  to
arithmetic  in a higher level language such as BASIC or  FORTRAN.
Registers  can  be  added,  subtracted,  but  multiplication  and
division  require  a short program.  Other instructions exist  to
compare two numbers and increment or decrement registers.

     When two numbers are added or subtracted there needs to be a
way  of  signalling a carry or borrow if this  has  occurred.  In
addition to a carry five other features of the operation, such as
=  to zero and negative or positive are signalled.  This is  done
using  the  flags,  which are shown in the  register  display  as
CZPSNH.  The  six flags are covered briefly below and are covered
in more detail in the chapter on the flags and on number basses.

The  C or carry flag is set if the result of an add is too  great
for the register to hold the value.  In subtraction it is set  if
the answer is less than 0, necessitating a borrow.

The Z or Zero flag,  which is set to 1 if the result is zero, and
reset to 0 if the result is not zero.

The  P flag is set when the parity is even,  and reset when it is
odd.  It  is also used by some instructions to signify overflow,
and  thus is sometimes written as the P/V flag.

The  S  or  Sign  flag,  which is set to 1 if the  result  of  an
operation is between 0 and 127, and reset to 0 if between 128 and
255.

The  H  or half carry flag,  which is used  when  converting  hex
values to BCD.  The N flag indicates whether the last instruction
was  an  add  or  subtract.  These flags  are  used  by  the  DAA
instruction.

                             Adding

The following code shows how to add two numbers.

LD A,5:ADD A,3   will produce

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
08 000000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

if you now type ADD A,255 then the result will be

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
07 100001 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

The  carry  flag  has been set to indicate that  the  answer  was
greater than 255.

If  you  now use ADD A,248 then the answer will be 0,  and the  Z
flag will be set.

The  8  bit  instructions all add either  a  number,  or  another
register  to  the A register.  The flags are set  on  the  result
contained in the A register as follows.

C or carry flag          1 if answer &gt;255 else 0
Z or zero flag           1 if answer = 0 else 0
P flag                   1 if overflow in twos complement else 0
S or sign flag           1 if 127&lt;answer&lt;256 else 0
N flag                   0
H or half carry flag     1 if carry from bit 3 to bit 4 else 0

                        16 bit arithmetic

If  you want to add numbers that are more than the 0-255 that can
be stored in the A register,  then the HL, IX or IY registers can
be used. Thus LD HL,1000H:LD BC,2000H:ADD HL,BC will give

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000000 2000 0000 3000 0000 0000 00 000000 0000 0000 0000 0000

The flags are set as follows.

C or carry flag          1 if answer &gt;65535 else 0
Z or zero flag           not changed
P flag                   not changed
S or sign flag           not changed
N flag                   0
H or half carry flag     1 if carry from bit 11 to bit 12 else 0


                8 bit and 16 bit ADD instructions

ADD A,A      ADD A,(HL)        ADD HL,BC      ADD IY,BC
ADD A,B      ADD A,(IX+d)      ADD HL,DE      ADD IY,DE
ADD A,C      ADD A,(IY+d)      ADD HL,HL      ADD IY,IY
ADD A,D                        ADD HL,SP      ADD IY,SP
ADD A,E                        ADD IX,BC
ADD A,H                        ADD IX,DE
ADD A,L                        ADD IX,IX
ADD A,n                        ADD IX,SP


                         Add with carry

                           8 bit group

This set of instructions are essentially the same as the ADD set,
but add the carry flag as well. The instruction is ADC instead of
ADD.  Thus  LD A 4:ADC A 3 would give an answer of 7 if the carry
flag was 0, but an answer of 8 if the carry flag was 1 before the
instruction.

The  ADC instruction allows multiple precision adding.  The least
most significant bytes are added,  and the carry is propogated to
the next most significant bytes by using ADC.

For the 8 bit ADC's using th A register the flags are affected

C or carry flag          1 if answer &gt;255 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC &lt;-128 or &gt;127 else 0
S or sign flag           1 if 127 &lt; n &lt; 256 else 0
N flag                   0
H or half carry flag     1 if carry from bit 3 to bit 4 else 0

                     8 bit ADC instructions

ADC A,A        ADC A,B        ADC A,C        ADC A,D
ADC A,E        ADC A,H        ADC A,L        ADC A,n
ADC A,(HL)     ADC A,(IX+d)   ADC A,(IY+d)

                        16 bit ADC group

The 16 bit ADC instructions use the HL register instead of the  A
register. The flags are affected as follows

C or carry flag          1 if answer &gt;65536 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC &lt;-32768 or &gt;32767 else 0
S or sign flag           1 if 32767 &lt; n &lt; 65536 else 0
N flag                   0
H or half carry flag     1 if carry from bit 11 else 0

                        16 bit ADC group

ADC HL,BC      ADC HL,DE      ADC HL,HL      ADC HL,SP


                           Subtracting

                          The SUB group

There are two subtraction instructions, SUB which is the opposite
of ADD, and SBC which is subtract with borrow. Thus

LD A,6:SUB 2  gives A = 4.

SUB  is  used for 8 bit subtractions.  The number or register  is
subtracted  from  the A register and the result stored in  the  A
register.  One of the idiosyncracities of the Z80 instrcution set
is that the A register is not written as it is with ADD,  viz ADD
A C but SUB C.  In addition although there are 16 bit ADD's there
are  no 16 bit SUB's. (16 bit subtraction is done using  the  SBC
instruction.) The flags are set as follows

C or carry flag          1 if answer &lt;0 else 0
Z or zero flag           1 if answer = 0 else 0
P flag                   1 if overflow in twos complement else 0
S or sign flag           1 if 127&lt;answer&lt;256 else 0
N flag                   1
H or half carry flag     1 if borrow from bit 4 else 0

                       SUB instruction set

SUB A      SUB B      SUB C      SUB D        SUB E        SUB H
SUB L      SUB n      SUB (HL)   SUB (IX+d)   SUB (IY+d)


                       Subtract with borrow

                           8 bit group

The  SBC instruction group is the opposite to the ADC group.  The
register or number is subvtracted from the A register, along with
the C flag, and the result stored in the A register. Thus

LD A,7:SBC A,3 gives A=4 if the carry flag was 0 and A=3 if  it
was 1 before the SBC.

The flags are affected as follows

C or carry flag          1 if &lt;0 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC &gt;127 or &lt;-128 else 0
S or sign flag           1 if 127 &lt; n &lt;256 else 0
N flag                   1
H or half carry flag     1 if borrow from bit 12 else 0


SBC A,A        SBC A,B        SBC A,C        SBC A,D
SBC A,E        SBC A,H        SBC A,L        SBC A,n
SBC A,(HL)     SBC A,(IX+d)   SBC A,(IY+d)

                  16 bit subtracts with borrow

These  instructions subtract the designated register from the  HL
register pair and store the answer in the HL register  pair.  The
flags are affected as follows

C or carry flag          1 if answer &lt; 0 else 0
Z or zero flag           1 if result = 0 else 0
P flag                   1 if TC &gt;32767 or &lt;-32768 else 0
S or sign flag           1 if 32767 &lt; n &lt; 65536 else 0
N flag                   1
H or half carry flag     1 if borrow from bit 12 else 0

                        16 bit SBC group

SBC HL,BC      SBC HL,DE      SBC HL,HL      SBC HL,SP


                            Compares

The  compare  instruction  can  be thought of as  an  8  bit  SUB
instruction  in  the way the flags are changed,  except that  the
contents of the A register remain unchanged. Thus

LD A,9:CP 9  gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
09 010010 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

where  for  example the zero flag has been set because 9  - 9  is
zero,  but the A register still contains the original 9.  The set
is

CP A      CP B      CP C      CP D        CP E        CP H
CP L      CP n      CP (HL)   CP (IX+d)   CP (IY+d)

                            Increment

Increments are the same as adding a 1.  Thus INC B is the same as
LD A,B:ADD A,1:LD B,A.  The results of all increments to  single
registers  affect  the  flags  as if an ADD  had  been  perfomed.
However for double register groups,  such as INC BC the registers
are  unaffected.  The first two columns are the 8 bit  increments
that  do  affect the flags,  and the last column is  the  16  bit
increments that leave the flags unchanged.


INC A      INC (HL)            INC BC
INC B      INC (IX+d)          INC DE
INC C      INC (IY+d)          INC HL
INC D                          INC IX
INC E                          INC IY
INC H                          INC SP
INC L

                            Decrement

These  are the opposite to the increment group,  the  subtract  1
from  the  register  in  question.   As  before  single  register
decrements  affect  the  flags as a subtract  would,  but  double
register decrements leave the flags as they are.


DEC A      DEC (HL)            DEC BC
DEC B      DEC (IX+d)          DEC DE
DEC C      DEC (IY+d)          DEC HL
DEC D                          DEC IX
DEC E                          DEC IY
DEC H                          DEC SP
DEC L

****************************************************************

                Chapter 5 Jumps Calls and Returns

     There  are  five instructions in this group.  JP and JR  are
like GOTO in basic,  and jump to the corresponding line.  CALL is
like  GOSUB,  and  calls  a  subroutine.  RET  returns  from  the
subroutine.

Jumps

The simplest type of jump is demonstrated by the following  short
program.

Line1:  LD A,5:JP Line 3
Line2:  end
line3:  LD B,6:END

Line2 is never encountered because the program jumps to Line3.

The next type of jump only occurs if the flag condition specified
by the jump is true.

Line1:  LD A,0:LD B,5
Line2:  ADD A,1:DEC B:JP NZ Line2
        END

Line1  loads B with 5.  The program now loops through line2
until  B is equal to 0.  This is because JP NZ only jumps if  the
result  of the last operation to affect the Z flag was not  zero.
Since  the zero flag is set to 0 by DEC B if B is not equal to  0
the program loops until B=0.

The following are the conditions that can be used with JP.

NZ        Jump if zero flag = 0. (last Z flag instr &lt;&gt;0)
Z         Jump if zero flag = 1. (last Z flag instr = 0)
NC        Jump if carry flag = 0. (last C instr = no carry)
C         Jump if carry flag = 1. (last C instr = carry)
PO        Jump if parity odd, parity flag = 0.
PE        Jump if parity even, parity flag = 1.
P         Jump if sign positive, sign flag = 0.
M         Jump if sign negative (minus), sign flag = 1.

Relative jumps

     In  the interpreter the JR instruction is the same as the JP
instruction. However there is a difference between the two in the
compiled  program.  The JR instruction,  instead of  storing  the
value  of  the  location  to  be  jumped  to,  instead  stores  a
displacement value,  which may be anything between +127 and -127.
A  displacement  value of say -3 says jump to the  instruction  3
bytes before this one.

     The  reasoning behind this is that relative jumps take  only
two  bytes  of memory wheras ordinary jumps take  three.  However
this memory saving is offset by the fact that ordinary jumps  are
quicker than relative jumps.  In addition conditional jumps PO PE
P and M are not allowed with JR.

     All this means that in practical terms it is probably better
to  ignore the JR instruction and to only use the JP  instuction.

DJNZ

The  third  type of jump is the DJNZ instruction.  The  following
program shows how it works.

Line1:  LD A,0:LD B,5
Line2:  ADD A,1:DJNZ Line2
        END

Line1 sets A to 0 and B to 5.  Line2 adds one to A.  The DJNZ
subtracts  one  from register B,  and if the result is  not  zero
jumps  to the location shown.  Thus the program loops through  20
until B is 0, and then ends.

                  Summary of Jump instructions

JP nn        JP Z,nn          JP PE,nn      JR NZ,nn
JP (HL)      JP NC,nn         JP P,nn       JR Z,nn
JP (IX)      JP C,nn          JP M,nn       JR NC,nn
JP (IY)      JP PO,nn         JR nn         JR C,nn
JP NZ,nn                                    DJNZ nn


Calls

Subroutines are called by a CALL and terminated by a RET.

Start:  LD A,5:CALL Subroutine
        END

Subroutine:LD B,4:ADD A,B:RET

The return location is stored in the stack.

CALL's  like  jumps can be conditional,  and the same  rules
apply. RET's can also be conditional.

     In addition there are two additional returns, RETI and RETN,
which   return   from  interupts  and  non  maskable   interrupts
respectively.   Since  interrupts  are  not  implemented  on  the
interpreter  these  two  instructions do  nothing.  They  can  be
included if they will be used in the final compiled program.

                             Summary

CALL nn                RET nn
CALL NZ,nn             RET NZ,nn
CALL Z,nn              RET Z,nn
CALL NC,nn             RET NC,nn
CALL C,nn              RET C,nn
CALL PO,nn             RET PO,nn
CALL PE,nn             RET PE,nn
CALL P,nn              RET P,nn
CALL M,nn              RET M,nn
                       RETI
                       RETN

**************************************************************

                       Chapter 6  AND OR and XOR

These  instructions all work on the A register and peform bit  by
bit comparisons with the appropriate register. For example

LD A,1010000B:LD B,0000001B:OR B gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
A1 000100 0100 0000 0000 0000 0000 00 000000 0000 0000 0000 0000


AND  OR and XOR perform bit by bit comparisons of the  designated
register and the A register according to the following rules.

         A register bit     other register bit     A bit set to

AND            0                    0                   0
               0                    1                   0
               1                    0                   0
               1                    1                   1

OR             0                    0                   0
               0                    1                   1
               1                    0                   1
               1                    1                   1

XOR            0                    0                   0
               0                    1                   1
               1                    0                   1
               1                    1                   0

The  flags  are also set by the result in  the  A  register,  the
details of which are in Ch 17.  Note that the AND command affects
the  H flag differently to the other two,  however all the  other
flags are affected the same way.

                        Instruction  set

(n  is  any  number or label that can be resolved into an  8  bit
number)

AND A         OR A         XOR A
AND B         OR B         XOR B
AND C         OR C         XOR C
AND D         OR D         XOR D
AND E         OR E         XOR E
AND H         OR H         XOR H
AND L         OR L         XOR L
AND n         OR n         XOR n

******************************************************************

                  Chapter 7 Bit set, reset and test

     The  instructions  in this group allow a specific bit  in  a
register or memory location to be set to 1,  reset to 0 or tested
to see if it is 1 or 0.

                               SET

LD C,0:SET 3,C

sets byte 3 of register 3 to 1.  The result is register C = 8  in
hexadecimal.

The following table shows how the bits are numbered in a byte.

                            01010101
                            76543210

Bit  7  on the left is the most significant bit and bit 0 on  the
right is the least significant.  For 16 bit numbers bit 15 is  on
the left and bit 0 is on the right.

The registers that can be set, reset or tested are

A   B  C  D  E  H  L  and the memory location pointed to by  (HL)
(IX+d) or (IY+d).

                               RES

The  RES instruction is the opposite of the SET  instruction,  it
changes the appropriate bit to 0. Thus

LD H,11111111B:RES 5,H

results in a value of 0DFH

Flags are not affected by either the SET or RES instructions.

                               BIT

The  BIT instruction is used to test whether a specific bit is  a
zero or a one.

LD D,10101010B:BIT 5,D  results in

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
00 000001 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

The  flags,  which  indicate the result of the test,  are set  as
follows.

C or carry flag          not affected
Z or zero flag           1 if bit is zero else 0
P or parity/overflow     may be anything
S or sign flag           may be anything
N or subtract flag       0
H or half carry flag     1

                     Summary of instructions

SET 0,A      SET 4,A      RES 0,A      RES 4,A      BIT 0,A      BIT 4,A
SET 0,B      SET 4,B      RES 0,B      RES 4,B      BIT 0,B      BIT 4,B
SET 0,C      SET 4,C      RES 0,C      RES 4,C      BIT 0,C      BIT 4,C
SET 0,D      SET 4,D      RES 0,D      RES 4,D      BIT 0,D      BIT 4,D
SET 0,E      SET 4,E      RES 0,E      RES 4,E      BIT 0,E      BIT 4,E
SET 0,H      SET 4,H      RES 0,H      RES 4,H      BIT 0,H      BIT 4,H
SET 0,L      SET 4,L      RES 0,L      RES 4,L      BIT 0,L      BIT 4,L
SET 0,(HL)   SET 4,(HL)   RES 0,(HL)   RES 4,(HL)   BIT 0,(HL)   BIT 4,(HL)
SET 0,(IX+d) SET 4,(IX+d) RES 0,(IX+d) RES 4,(IX+d) BIT 0,(IX+d) BIT 4,(IX+d)
SET 0,(IY+d) SET 4,(IY+d) RES 0,(IY+d) RES 4,(IY+d) BIT 0,(IY+d) BIT 4,(IY+d)
SET 1,A      SET 5,A      RES 1,A      RES 5,A      BIT 1,A      BIT 5,A
SET 1,B      SET 5,B      RES 1,B      RES 5,B      BIT 1,B      BIT 5,B
SET 1,C      SET 5,C      RES 1,C      RES 5,C      BIT 1,C      BIT 5,C
SET 1,D      SET 5,D      RES 1,D      RES 5,D      BIT 1,D      BIT 5,D
SET 1,E      SET 5,E      RES 1,E      RES 5,E      BIT 1,E      BIT 5,E
SET 1,H      SET 5,H      RES 1,H      RES 5,H      BIT 1,H      BIT 5,H
SET 1,L      SET 5,L      RES 1,L      RES 5,L      BIT 1,L      BIT 5,L
SET 1,(HL)   SET 5,(HL)   RES 1,(HL)   RES 5,(HL)   BIT 1,(HL)   BIT 5,(HL)
SET 1,(IX+d) SET 5,(IX+d) RES 1,(IX+d) RES 5,(IX+d) BIT 1,(IX+d) BIT 5,(IX+d)
SET 1,(IY+d) SET 5,(IY+d) RES 1,(IY+d) RES 5,(IY+d) BIT 1,(IY+d) BIT 5,(IY+d)
SET 2,A      SET 6,A      RES 2,A      RES 6,A      BIT 2,A      BIT 6,A
SET 2,B      SET 6,B      RES 2,B      RES 6,B      BIT 2,B      BIT 6,B
SET 2,C      SET 6,C      RES 2,C      RES 6,C      BIT 2,C      BIT 6,C
SET 2,D      SET 6,D      RES 2,D      RES 6,D      BIT 2,D      BIT 6,D
SET 2,E      SET 6,E      RES 2,E      RES 6,E      BIT 2,E      BIT 6,E
SET 2,H      SET 6,H      RES 2,H      RES 6,H      BIT 2,H      BIT 6,H
SET 2,L      SET 6,L      RES 2,L      RES 6,L      BIT 2,L      BIT 6,L
SET 2,(HL)   SET 6,(HL)   RES 2,(HL)   RES 6,(HL)   BIT 2,(HL)   BIT 6,(HL)
SET 2,(IX+d) SET 6,(IX+d) RES 2,(IX+d) RES 6,(IX+d) BIT 2,(IX+d) BIT 6,(IX+d)
SET 2,(IY+d) SET 6,(IY+d) RES 2,(IY+d) RES 6,(IY+d) BIT 2,(IY+d) BIT 6,(IY+d)
SET 3,A      SET 7,A      RES 3,A      RES 7,A      BIT 3,A      BIT 7,A
SET 3,B      SET 7,B      RES 3,B      RES 7,B      BIT 3,B      BIT 7,B
SET 3,C      SET 7,C      RES 3,C      RES 7,C      BIT 3,C      BIT 7,C
SET 3,D      SET 7,D      RES 3,D      RES 7,D      BIT 3,D      BIT 7,D
SET 3,E      SET 7,E      RES 3,E      RES 7,E      BIT 3,E      BIT 7,E
SET 3,H      SET 7,H      RES 3,H      RES 7,H      BIT 3,H      BIT 7,H
SET 3,L      SET 7,L      RES 3,L      RES 7,L      BIT 3,L      BIT 7,L
SET 3,(HL)   SET 7,(HL)   RES 3,(HL)   RES 7,(HL)   BIT 3,(HL)   BIT 7,(HL)
SET 3,(IX+d) SET 7,(IX+d) RES 3,(IX+d) RES 7,(IX+d) BIT 3,(IX+d) BIT 7,(IX+d)
SET 3,(IY+d) SET 7,(IY+d) RES 3,(IY+d) RES 7,(IY+d) BIT 3,(IY+d) BIT 7,(IY+d)

****************************************************************

                 Chapter 8 Rotate and shift group


The  instructions in this chapter are concerned with shifting  or
rotating the bits in a particular register. For example

10001000     shifted right becomes 01000100


                          Rotate group

There  are  four instructions that rotate the contents of  the  A
register only.

                              RLCA

RLCA rotates the A register to the left one place. The 7th bit is
put back into the 0 position.  The 7th bit also goes to the carry
flag.

LD A,10011000B:RLCA  gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
31 100000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

Use View Registers to see the value of A in binary= 00110001B

The flags are affected as follows

C or carry flag          previous bit 7 value
Z or zero flag           not affected
P or parity/overflow     not affected
S or sign flag           not affected
N or subtract flag       0
H or half carry flag     0

The RLCA instruction can be represented symbolically as


C  &lt;---   bbbbbbbb &lt;-
       |             |
        -------------


                               RLA

The RLA instruction rotates left through the carry flag.

 --- C &lt;---  bbbbbbbb  &lt;--
|                         |
------------- &gt; ----------

The  bits in the register are all rotated left,  the 7th bit goes
to the carry flag and the carry flag goes to bit 0.

LD A,1 then

RLA 9 times, looking at the value of A each time will clarify the
operation of this instruction.

Apart from the carry flag, the other flags are set as for RLCA.

                              RRCA

This  rotates  the  register  right in a  similar  way  to  RLCA.
Symbolically

 ---&gt; bbbbbbbb ---&gt; C
|              |
 ------ &lt; -----

The  register is shifted right by one,  and the 0 bit goes to the
carry flag and to the 7th bit.  Flags apart from the carry are as
for RLCA.

                               RRA

The RRA rotates right through the  carry flag

 ---&gt; bbbbbbbb ---&gt; C --
|                       |
 ----------- &lt; ---------

The register is shifted right by one, the 0 bit goes to the carry
flag,  and  the carry flag goes to bit 7.  Flags apart  from  the
carry flag are as for RLCA.


                 Rotates through other registers

The next set of instructions are similar to the above, but act on
any one of A B C D E H L (HL) (IX+d) or (IY+d).  They also affect
the flags differenty.

                               RLC x

The RLC instruction rotates the register left by one.  It can  be
represented symbolically as

C  &lt;---   bbbbbbbb &lt;-
       |             |
        -------------

To demonstrate this instruction type

LD D,1 and then

RLC D   until the 1 has gone all the way round.

The flags are affected as follows

C or carry flag          previous bit 7 value
Z or zero flag           1 if result is zero, else 0
P or parity/overflow     1 if parity even, else 0
S or sign flag           1 if 127&lt;result&lt;256, else 0
N or subtract flag       0
H or half carry flag     0



                               RL x

The RL instruction rotates the register through the carry flag.

                    --- C &lt;---  bbbbbbbb  &lt;--
                   |                         |
                   ------------- &gt; ----------

The  register  is rotated left by one,  the 7th bit goes  to  the
carry  flag,  and the carry flag goes to the 0 bit.  Flags  apart
from  the  carry  flag  are as for RLC.  RL  works  on  the  same
registers as RLC.

                               RRC x

The RRC instruction rotates the register right.

                         ---&gt; bbbbbbbb ---&gt; C
                        |              |
                         ------ &lt; -----

The register is rotated right by one, the 0 bit goes to bothe the
carry  flag and the 7th bit.  Flags apart from the carry flag are
as for RLC. RRC works on the same registers as RLC.

                              RR x

The  RR instruction rotates the register right through the  carry
flag.
                   ---&gt; bbbbbbbb ---&gt; C --
                  |                       |
                   ----------- &lt; ---------

The register is rotated right by one, the 0 bit goes to the carry
flag and the carry flag goes to the 7th bit.


                    The four bit rotate group

There  are two instructions in this group that rotate  groups  of
bits  through the A register and a memory location pointed to  by
the (HL) register.

                               RLD

The  RLD  instruction takes groups of four bits and rotates  them
as shown symbolically.

 -----&gt;-----                        --------&gt;----------
12 ---&lt;--- 34           or     1    2 -----&lt;---- 3 &lt;-- 4
           ^|
            -
A         (HL)                   A                 (HL)

     The register on the left is the A register and the  register
on  the right is a memory location pointed to by the HL register.
The 4 least significant bits of the A register are moved to the 4
least  significant  bits  of  the  (HL)  location.  The  4  least
significant  bits  of the (HL) location are moved to the  4  most
significant  bits of the (HL) location.  The 4  most  significant
bits  of  the (HL) location are moved to the 4 least  significant
bits  of  the A register.  The 4 most significant bits of  the  A
register remain unchanged.

LD  A,12H:LD HL,1000H:LD (HL),34H sets up the registers as  shown
above.

RLD  results in

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
13 000000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

with View Memory giving address 1000H = to 42H.

     The flags are set as follows

C or carry flag          not affected
Z or zero flag           1 if result is zero, else 0
P or parity/overflow     1 if parity even, else 0
S or sign flag           1 if 127&lt;result&lt;256, else 0
N or subtract flag       0
H or half carry flag     0


                               RRD

The RRD instruction can be represented as follows.

                        ---------&lt;--------------
                 1      2 -------&gt;----- 3 --&gt;-- 4
                    A                      (HL)

The  instruction does the reverse of RLD.  The flags are  as  for
RLD.



                         The Shift group


There are three instructions in this group,  that can work on the
following registers; A B C D E H L (HL) (IX+d) or (IY+d).


                              SLA x

This   instruction   shifts   the   designated   register   left.
Symbolically

                     C &lt;--- bbbbbbbb &lt;--- 0

The  register is shifted left one place.  The 7th bit goes to the
carry flag. The 0 bit has a 0 shifted in.

LD E,1 and then SLA E,9 times will demonstrate this instruction.

Flags are set as follows

C or carry flag          from bit 7
Z or zero flag           1 if result is zero, else 0
P or parity/overflow     1 if parity even, else 0
S or sign flag           1 if 127&lt;result&lt;256, else 0
N or subtract flag       0
H or half carry flag     0


                              SRA x

This  instruction shifts the designated register right one place.
Symbolically

                  --&gt; bbbbbbbb ----&gt; C
                  -&lt;--

The bits are all shifted right one.  The 0 bit goes to the  carry
flag.  The  7th bit however stays the same,  although the 6th bit
equals the old 7th bit.  The flags apart from the carry flag  are
as for SLA.

LD C 10000000B and then SRA C   9 times will demonstrate this.


                              SRL x

This instruction shifts all the bits right. Symbolically

                0 ---&gt; bbbbbbbb ---&gt;C

The  bits are all shifted right one.  The 0 bit goes to the carry
flag. The 7th bit is replaced with a 0. Flags are as for SLA.


                Summary of rotate and shift group

RLCA        RL A        RR A         SRA A
RLA         RL B        RR B         SRA B
RRCA        RL C        RR C         SRA C
RRA         RL D        RR D         SRA D
RLD         RL E        RR E         SRA E
RRD         RL H        RR H         SRA H
RLC A       RL L        RR L         SRA L
RLC B       RL (HL)     RR (HL)      SRA (HL)
RLC C       RL (IX+d)   RR (IX+d)    SRA (IX+d)
RLC D       RL (IY+d)   RR (IY+d)    SRA (IY+d)
RLC E       RRC A       SLA A        SRL A
RLC H       RRC B       SLA B        SRL B
RLC L       RRC C       SLA C        SRL C
RLC (HL)    RRC D       SLA D        SRL D
RLC (IX+d)  RRC E       SLA E        SRL E
RLC (IY+d)  RRC H       SLA H        SRL H
            RRC L       SLA L        SRL L
            RRC (HL)    SLA (HL)     SRL (HL)
            RRC (IX+d)  SLA (IX+d)   SRL (IX+d)
            RRC (IY+d)  SLA (IY+d)   SRL (IY+d)

************************************************************

                           Chapter 9

        General purpose arithmetic and CPU control group

                               NOP

This is the simplest Z80 instruction, and simply does nothing.

        NOP:NOP:NOP:END

NOP's are useful for creating delays.

                              HALT

This  instruction halts the CPU.  In the interpreter this returns
control to programmer,  and is equivalent to STOP in BASIC.
In the microprosessor this stops  program
execution until an interrupt is recieved.  The Z80 performs NOP's
to ensure proper memory refresh.


                               DI

DI disables the interrupts. Since interrupts are not supported by
the interpreter the interpreter ignores this instruction. To find
out  more  about how the various types of interrupts work on  the
Z80 consult one of the Z80 texts.

        LD A,4:DI:LD B,3:EI:END

                               EI

EI enables the interrupts. See DI

                              IM n

This  instruction  sets  the interrupt mode.  As with  EI  it  is
ignored by the interpreter. n can be one of 0 1 or 2. Thus

        IM 2:LD A,5:IM 0:END

                               SCF

SCF sets the carry flag to 1.

        LD A 5:SCF:END  gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
05 100000 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

The Z,  P and S flags are unaffected. The N and H flags are reset
to 0.

To set the carry flag to 0 use SCF then CCF.


                               CCF

CCF complements the carry flag. If the flag was 1 it is now 0 and
vice  versa.  The Z P and S flags are unaffected.  The N flag  is
reset to 0. The H flag may be anything.

                               NEG

NEG  negates  the  A register.  The  mathematical  equivalent  is
A = 0-A. Thus

LD A,5:NEG gives

A  CZPSNH  BC   DE   HL   IX   IY  A' CZPSNH' BC'  DE'  HL'  SP
FB 000111 0000 0000 0000 0000 0000 00 000000 0000 0000 0000 0000

Flags are set as follows

C or carry flag          1 if A=0 before operation, else 0
Z or zero flag           1 if result is zero, else 0
P or parity/overflow     1 if A=128 before operation, else 0
S or sign flag           1 if 127&lt;result&lt;256, else 0
N or subtract flag       1 if borrow from bit 4 else 0
H or half carry flag     1


                               CPL

CPL  complements the A register.  All 0's become 1's and all  1's
0's. The C, Z P and S flags are all unaffected. The N and H flags
are both set to 1.


                               DAA

DAA  decimally adjusts the accumulator.  This instruction  allows
decimal numbers to be added. For example let us add 11H and 22H

LD A,11H:ADD A,22H which gives A = 33H

However if we add 22H and 39H

LD A,22H:ADD A,39H we get A = 5BH

The  B is illegal in decimal,  or BCD,  and is corrected by using
DAA. Thus

LD A 22H:ADD A 39H:DAA gives A = 61H, which is correct.

Other examples

LD A,91H:ADD A,92H unadjusted gives 23H,  adjusted with DAA gives
83H and carry = 1 (use to get 183)

LD A,99H:ADD A,99H unadjusted gives 32H,  adjusted with DAA gives
98H and carry = 1.

DAA also can be used after subtraction

LD A,99H:SUB A,11H unadjusted gives 88H,  adjusted with DAA gives
88H.

LD A,91H:SUB A,19H unadjusted gives 78H,  adjusted with DAA gives
72H.

LD A,19H:SUB A,91H unadjusted gives 88H,  adjusted with DAA gives
28H and carry = 1. (carry is used as borrow in subtracts)

LD A,11H:SUB A,99H unadjusted gives 78H,  adjusted with DAA gives
12 and carry = 1.

The  way DAA works is to selectively add numbers according to the
value  in  A,  and to the C H and N flags.  In fact this  is  the
purpose  of the H and N flags as no other instruction uses  them.
The value added is given by the following table,  although it  is
not necessary to understand or even to have the table to use DAA.
DAA  should  always  be  used immediately after the  ADD  or  SUB
instruction  to avoid flags being changed.  DAA can also be  used
with ADC INC SBC DEC NEG etc.

N   C   Value of     H  Value of     Hex no   C flag after
        high nibble     low nibble   added    execution

0   0      0-9       0     0-9       00       0
0   0      0-8       0     A-F       06       0
0   0      0-9       1     0-3       06       0
0   0      A-F       0     0-9       60       1
0   0      9-F       0     A-F       66       1
0   0      A-F       1     0-3       66       1
0   1      0-2       0     0-9       60       1
0   1      0-2       0     A-F       66       1
0   1      0-3       1     0-3       66       1
1   0      0-9       0     0-9       00       0
1   0      0-8       1     6-F       FA       0
1   1      7-F       0     0-9       A0       1
1   1      6-F       1     6-F       9A       1


Flags are affected by DAA as follows

C or carry flag          as per table
Z or zero flag           1 if A=0 else 0
P or parity/overflow     1 if parity even else 0
S or sign flag           1 if msb A = 1 else 0
N or subtract flag       unaffected
H or half carry flag     may be anything
                           Chapter 11

                 Block transfer and search group

Four  instructions exist in the Z80 instruction set that are used
to  transfer blocks of data from one memory location to  another.
Another  set of four instructions allow searches through a set or
memory locations for a specific byte.

             Block transfer group; LDI LDD LDIR LDDR

LDI

LDI  moves a block of data. HL is the memory location to move
from, DE is the memory location to move to and BC is the
number of bytes to move.

memory contents (DE) = memory contents (HL)
DE = DE + 1
HL = HL + 1
BC = BC - 1

At the end of each loop the P flag indicates if BC is 0 (P=1
if &lt;&gt;0 and 0 if = to 0)

C, Z and S flags are not affected
H and N flags are reset to 0
P flag =1 if after LDI BC is not equal to 0, else P = 0


LDD

LDD  is the same as LDI except that the DE and HL  registers  are
decremented. Thus

(DE) = (HL)
DE = DE - 1
HL = HL - 1
BC = BC - 1

The  flags are the same as for LDI.  Thus the program above would
be rewritten

LDIR

This is the automatic version of LDI.  Set the HL, DE and BC
registers and then run LDIR. If BC is a high value the
instruction can take a while to execute.

LDIR does the following

(DE) = (HL)
DE = DE + 1
HL = HL + 1
BC = BC - 1 and repeats until BC = 0

Flags are a little different;

C, Z and S unchanged
H, N and P = 0

LDDR

This instruction is the automatic version of LDD. The summary is

(DE) = (HL)
DE = DE - 1
HL = HL - 1
BC = BC - 1 and repeat until BC = 0

Flags are as for LDIR.

The  question  may  be asked;  why use LDI  when  LDIR  does  the
operation automatically.  The reason is that the registers can be
changed when using LDI. For instance you can transfer every
alternate bytethis program transfers every
alternate byte between instructions by inserting say a INC
HL.

                            oooOOOooo

                       Block search group

The next four instructions are concerned with searching for bytes
in a block of data.

CPI

CPI searches starting at the memory location pointed to by the HL
register,  and  searches  for  BC number of bytes  for  the  byte
in register A.

A - (HL) and set flags on the result of this compare,  equivalent
         to CP (HL)
HL = HL + 1
BC = BC - 1

The flags are set as follows

C = no change
Z = 1 if A - (HL) = 0 else 0
P = 1 if BC &lt;&gt; 0 after instruction else 0
S = 1 if sign A - (HL) negative in two's comp, else 0
H = 1 if a half carry from A - (HL)
N = 1

CPD

CPD  is  the  same  as  CPI  except  that  the  HL  register   is
decremented;  HL = HL - 1. The flags are as for CPI.

CPIR

This  is  the automatic version of CPI.  The instruction  repeats
until either A = (HL) or BC = 0.  The flags are as for CPI.


CPDR

This is the automatic version of CPD.

Flags are as for CPI.

***************************************************************

               Chapter 11 Input and output

The  Z80  has several comands that input and output data  to  the
ports.  However  many of these are not very useful,  and only one
input and one output instruction are used in most Z80  computers.
These are the IN A (n) and OUT (n) A instructions, where n is the
port number between 0 and 255.
Inputs and outputs do nothing on the ZINT interpreter, as
these depend on the actual hardware used.


OTDR                            INDR
OTIR                            INIR
OUTD                            IND
OUTI                            INI
OUT (C),A                       IN A,(C)
OUT (C),B                       IN B,(C)
OUT (C),C                       IN C,(C)
OUT (C),D                       IN D,(C)
OUT (C),E                       IN E,(C)
OUT (C),H                       IN H,(C)
OUT (C),L                       IN L,(C)
OUT (n),A                       IN A,(n)

***************************************************************


                 Chapter 12  Addtional commands

Apart  from  the  instructions  that  generate  code,  there  are
additional  commands  which  are  needed  to  test  and  run  the
programs. These shall be looked at in alphabetical order.

                        The semicolon  ;

The semicolon is used to indicate a remark. These are ignored by
the program.

        LD A,5:; This loads the A register with 5:LD B,3:END

Instructions can be added after the remark, as is the LD B,3.


                               END

END  is used to indicate the end of a program.  It should  always
be  the last statement in a program,  otherwise an error  message
will appear.

                               EQU

EQU is used to set labels to particular values.

VARIABLE1 EQU 46H

Later  in the program,  instead of writing say LD A,46H,  we  can
write LD A,VARIABLE1.  This enables the way the program works to
be made a lot clearer.

The  label  used,  in this case VARIABLE1 can be any sequence  of
letters or numbers,  but should be 3 or more letters  long.  Thus
EQU X 5 is not allowed.  The number can be decimal, hex or binary
number.

To  see  what  the  current values of the labels  are  the
View Label command is used.

Labels  should be assigned values before they are encountered  in
the  program.  The value of a label cannot be changed once it has
been assigned.

                               ORG

ORG is used to set the origin of the program when it is compiled.
When  the program is finally dumped into a Z80 computer's memory,
some way of indicating where the program will start is needed. In
the  Z80  it  is customary to start the  program  not  in  memory
location 0 but at memory location 100H.  The first instruction in
the  program  is  a jump to location 100H.  This is  because  the
interrupts jump to locations between 5H and 100H. Thus a standard
way to start a program is

        ORG 0:JP 100H:ORG 100H
        LD A,5 etc...

the  interrupts  themselves  are usually  jumps  also.  Thus  the
interrupt at location 66H could be set by

        ORG 66H:JP Interrupt
Interrupt:LD A,5 etc program to service interrupt.

ORG  is  probably best ignored until you are  familiar  with  the
other  instructions,  as  it  is not necessary  to  write  simple
programs.

***************************************************************

                  Chapter 13 Number Bases

     This chapter explains the number bases that are used by  the
interpreter.  The appendix contains all the conversions from 0 to
255.  For  numbers larger than this the BASE command can be used.
The  bases  to  be cavered  are  binary,  hexadecimal  and  two's
complement.

                             Binary

     Binary  is  the system of counting used by computers  as  it
only has two digits,  0 and 1. A number in binary is written with
a B on the end to differentiate it from the other bases; 1011B

                           Hexadecimal

     Hexadecimal or Hex numbers use a base of 16,  rather than 10
used in the decimal system. The digits used are 0 1 2 3 4 5 6 7 8
9 A B C D E F
     Hex  numbers have a H on the end.  In addition all H numbers
should  start with a number from 0 to 9 to distinguish them  from
text. A 0 is usually added to the beginning for this reason. Some
examples of hex numbers are
0D3H    0FFH   012H  0ABCDH  28E6H  0H


                        Two's complement

     Two's complement is a number system that ranges from -128 to
+127.  The  result of the sum in two's complement is used to  set
one of the registers in the Z80;  the overflow register.  Numbers
from 0 to 127 in decimal are the same in twos complement. However
from 128 to 255 all two's complement numbers are negative.
     TC  numbers  are  calculated by  subtracting  256  from  the
dicimal  number  if  the decimal number is between  128  and  255
inclusive.  Thus 255 is -1 in TC, 128 is -128 and 45 is 45. There
is no special ending to distinguish TC numbers, the - sign is all
that is needed.

                           Other bases

Other bases such as octal are not used by the interpreter.  ASCII
symbols  may  be used providing they are in the range 32 to  127.
They are written in quotes,  thus LD A "s" results in A being  73
hex or 115 decimal, which is the ascii value for small s.

*****************************************************************

                     Chapter 14 The flags

This  chapter  discusses  the 6 flags used by the  Z80,  and  the
conditions  which affect them.  The flags are represented in  the
register display by the symbols CZPSNH.

                       The Z or zero flag

The Z flag is set to 1 of the result of an operation is 0. If the
result  is other than 0 then the Z flag is reset to 0.  The table
below summarizes the instructions that affect the Z flag.

Group             Instruction                   Action

8 bit               LD A I        Z = 1 if register = 0 else 0
load group          LD A R        Z = 1 if register = 0 else 0

Search group        CPI, CPIR,    Z = 1 if A = (HL) else 0
                    CPD, CPDR

                    ADD A x       Z = 1 if register = 0 else 0
                    ADC A x                  "
                    SUB x                    "
                    SBC A x                  "
                    AND x                    "
8 bit               OR x                     "
arithmetic          XOR x                    "
group               CP x                     "
                    INC x                    "
                    DEC x                    "

General purpose     DAA                      "
arithmetic group    NEG                      "

16 bit              ADC HL xx                "
arithmetic group    SBC HL xx                "

                    RLC x                    "
                    RL x                     "
                    RRC x                    "
Rotate and          RR x                     "
shift group         SLA x                    "
                    SRA x                    "
                    SRL x                    "
                    RLD                      "
                    RRD                      "

Bit test group      BIT n x       Z = 1 if bit = 0 else 0

Input and           INR (C)       Z = 1 if input data =0 else 0
output group        INI, IND,     Z = 1 if B-1=0 else 0
                    INIR, INDR,   Z = 1
                    OUTI, OUTD,   Z = 1 if B-1=0 else 0
                    OTIR, OTDR    Z = 1

                       The S or sign flag

The  sign  flag is used to indicate whether  in  twos  complement
notation  a number is negative or positive.  (see chapter 16  for
more  about two's complement) Thus if the number is  negative  (-
128 to -1)  then  the  sign flag is set to 1.  If the  number  is
positive (0 to 127) then the sign flag is reset to 0.

Group       Instruction                   Action

8 bit         LD A I         S = 1 if I register negative else 0
load group    LD A R         S = 1 if R register negative else 0

Search        CPI,CPIR,      S = 1 if result negative else 0
group         CPD,CPDR                       "

              ADD A x                        "
              ADC A x                        "
              SUB x                          "
8 bit         SBC A x                        "
arithmetic    AND x                          "
group         OR x                           "
              XOR x                          "
              CP x                           "
              INC x                          "
              DEC x                          "

General purp  DAA                            "
arithmetic    NEG                            "

16 bit        ADC HL xx                      "
arithmetic    SBC HL xx                      "

              RLC x                          "
              RL x                           "
              RRC x                          "
Rotate and    RR x                           "
shift group   SLA x                          "
              SRA x                          "
              SRL x                          "
              RLD x          S = 1 if A negative else 0
              RRD x          S = 1 if A negative else 0

Bit test gp   BIT n x        may be anything

            / IN R (C)       S = 1 if input data negative else 0

Input and     INI,INIR,
output        IND,INDR,      may be anything
group         OUTI,OTIR,
            \ OUTD,OTDR



                       The C or carry flag

The  carry  flag  is used to indicate whether the  result  of  an
operation (in decimal) was greater than 255 or less than 0.

LD A,150:ADD A,200

results in an answer of 350,  which is adjusted to 94 ( or 5EH in
hex  )  by  subtracting  256,  and the  carry  flag  is  set.  In
subtraction the carry flag is used as a borrow,  and is set to  1
if  the  answer was less then 0,  and so had to be  corrected  by
adding 256.

LD A,100:SUB 210

results in -110,  which is adjusted to 146 ( 92H ) by adding 256,
and the carry flag is set to 1.

Group       Instruction                   Action

          /   ADD A x       C = 1 if carry from bit 7 else 0
              ADC A x                        "
8 bit         SUB x         C = 1 if borrow else 0
arithmetic    SBC A x                        "
group         AND                          C = 0
              OR                           C = 0
              XOR                          C = 0
          \   CP            C = 1 if borrow else 0

General   /   DAA           C = 1 if bcd carry else 0
purpose       NEG           C = 1 if A not 0 before negate else 0
arithmetic    CCF           C = 1 if C = 0 before CCF else 0
group     \   SCF           C = 1

          /   ADD HL xx     C = 1 if carry from bit 15 else 0
16 bit        ADC HL xx                      "
arithmetic    ADD IX xx                      "
group         ADD IY xx                      "
          \   SBC HL xx     C = 1 if borrow else 0

          /   RLCA          C = previous A bit 7
              RLA                            "
              RRCA          C = previous A bit 0
Rotate        RRA                            "
and shift     RLC x         C = previous bit 7 of operand
group         RL x                           "
              RRC x         C = previous bit 0 of operand
              RR x                           "
              SLA x         C = previous bit 7 of operand
              SRA x         C = previous bit 0 of operand
          \   SRL x         C = previous bit 0 of operand




              The P or P/V parity or overflow flag

As  the  heading suggests this flag has more than  one  function.

Parity.  The  parity of a byte is the number of 1's the byte  has
when  it  is  represented  in binary.  43 decimal  in  binary  is
00101011,  which  has  4  1's.  If  the number  of  1's  is  even
(including 0) then the byte has even parity and the P flag is set
to  1.  59  in binary is 00111110 which has 5 1's and thus the  P
flag  is  set to 0.  The instructions which use the P flag  as  a
parity flag are indicated in the table.

Overflow. This is the other major use for the P flag. Most of the
arithmetic instructions use the P flag as an overflow  flag,  and
this is why the flag is sometimes written as P/V. Overflow occurs
when,  during  a  two's complement addition the result  in  two's
complement is &gt;127 or &lt;-128.  (see the chapter on bases for  more
about  two's  complement).  If this error condition occurs the  P
flag is set to 1, otherwise it is set to 0.

The P flag is also used by the block transfer  instructions,  and
is set to 1 if after the instruction the BC register is not equal
to 0.


Group       Instruction                   Action

8 bit         LD A I        P = contents of IFF2
load group    LD A R                         "

Block       / LDI, LDD,     P = 1 if BC - 1 &lt;&gt; 0 else 0
transfer      CPI, CPIR,                     "
and load      CPD, CPDR                      "
group       \ LDIR, LDDR                   P = 0

            / ADD A x       P = 1 if overflow else 0
              ADC A x                        "
              SUB x                          "
8 bit         SBC A x                        "
arithmetic    AND x         P = 1 if parity even else 0
group         OR x                           "
              XOR x                          "
              CP x          P = 1 if overflow else 0
              INC x         P = 1 if x=7FH before, else 0
            \ DEC x         P = 1 if x=80H before, else 0

Gen purp      DAA           P = 1 if A parity even
arithmetic    NEG           P = 1 if A = 80H before, else 0

16 bit        ADC HL xx     P = 1 if overflow else 0
arithmetic    SBC HL xx                      "

            / RLC x         P = 1 if perity even else 0
              RL x                           "
              RRC x                          "
Rotate and    RR x                           "
shift group   SLA x                          "
              SRA x                          "
              SRL x                          "
              RLD x                          "
            \ RRD x                          "

Bit test gp   BIT n x       may be anything

            / IN R (C)      P = 1 if parity even else 0
Input and     INI,INIR,              may be anything
output        IND,INDR,                      "
group         OUTI,OTIR,                     "
            \ OUTD,OTDR                      "

The  following  are a list of 8 bit  additions  and  subtractions
showing the calculation in decimal and in two's complement,  with
the  effect on the S C and P flags.  None of the answers are zero
so the Z flag is zero for all of these.

D  64 + 65 = 129                  C = 0
TC 64 + 65 = 129 -&gt; -127          P = 1   S = 1

D  255 + 255 = 510 -&gt; 254         C = 1
TC -1 + -1 = -2                   P = 0   S = 1

D  192 + 191 = 383 -&gt; 127         C = 1
TC -64 + -65 = -129 -&gt; 127        P = 1   S = 0

D  6 + 8 = 14                     C = 0
TC 6 + 8 = 14                     P = 0   S = 0

D  127 + 1 = 128                  C = 0
TC 127 + 1 = 128 -&gt; -128          P = 1   S = 1

D  4 + 254 = 258 -&gt; 2             C = 1
TC 4 + -2 = 2                     P = 0   S = 0

D  254 + 252 = 506 -&gt; 250         C = 1
TC -2 + -4 = -6                   P = 0   S = 1

D  2 + 252 = 254                  C = 0
TC 2 + -4 = -2                    P = 0   S = 1

D  129 + 194 = 323 -&gt; 67          C = 1
TC -127 + -62 = -189 -&gt; 67        P = 1   S = 0

D  254 - 129 = 125                C = 0
TC -2 - -127 = 125                V = 0   S = 0

D  196 - 91 = 105                 C = 0
TC -60 - 91 = -151 -&gt; 105         P = 1   S = 0

D  12 - 60 = -48 -&gt; 208           C = 1
TC 12 - 60 = -48                  P = 0   S = 1

D  146 - 231 = -85 -&gt; 171         C = 1
TC -110 - 231 = -341 -&gt; -85       P = 1   S = 1


       The N or subtract flag and the H or half carry flag

These two flags are used for BCD adds and subtracts.  The DAA  is
the only instruction that uses these two flags, but the flags are
affected by most of the instruction groups.  The H flag indicates
a  carry  from  bit 3 in addition,  and a borrow from  bit  4  in
subtraction. The N flag is 0 after an add and 1 after a subtract.


Group       Instruction          H flag                 N flag

8 bit         LD A I     0                                0
load group    LD A R     0                                0

Block       / LDI, LDIR, 0                                0
transfer &amp;    LDD, LDDR, 0                                0
Search        CPI, CPIR, 1 if borrow from bit 4 else 0    1
group       \ CPD, CPDR                  "

              ADD A x    1 if carry from bit 3 else 0     0
              ADC A x                    "                0
              SUB x      1 if borrow from bit 4 else 0    1
8 bit         SBC A x                    "                1
arithmetic    AND x          1                            0
group         OR x           0                            0
              XOR x          0                            0
              CP x       1 if borrow from bit 4 else 0    1
              INC x      1 if carry from bit 3 else 0     0
              DEC x      1 if borrow from bit 4 else 0    1

General purp  DAA            anything                  no change
arithmetic    NEG            1 if borrow bit 4 else 0     1
              CPL            1                            1
              CCF            no change                    0
              SCF            0                            1

16 bit        ADC HL xx  1 if carry from bit 11 else 0    0
arithmetic    ADD HL xx                  "                0
              ADD IX xx                  "                0
              ADD IY xx                  "                0
              SBC HL xx  1 if borrow from bit 12 else 0   1

              RLCA           0                            0
              RLA            0                            0
              RRCA           0                            0
              RRA            0                            0
              RLC x          0                            0
              RL x           0                            0
              RRC x          0                            0
Rotate and    RR x           0                            0
shift group   SLA x          0                            0
              SRA x          0                            0
              SRL x          0                            0
              RLD x          0                            0
              RRD x          0                            0

Bit test gp   BIT n x        1                            0

            / IN R (C)       0                            0

Input and     INI,INIR,      anything                     1
output        IND,INDR,      anything                     1
group         OUTI,OTIR,     anything                     1
            \ OUTD,OTDR      anything                     1


                      More about the flags

     The  6  flags  are sometimes grouped into the  so  called  F
register.  This register is combined with the A register to  form
the AF register, which is used in such instructions as EX AF AF',
PUSH AF and POP AF. The flags are assigned as follows.

Flag            S   Z   -   H   -   P   N   C

Binary bit      7   6   5   4   3   2   1   0

****************************************************************

                       Appendix

       Values and conversion of bases and ASCII characters

1 = value in decimal
2 = value in hexadecimal
3 = value in binary
4 = value in two's complement
5 = ASCII charater if valid

 1      2         3         4          5

 0      00     00000000     0     CONTROL SHIFT P, NULL
 1      01     00000001     1     CONTROL A
 2      02     00000010     2     CONTROL B
 3      03     00000011     3     CONTROL C
 4      04     00000100     4     CONTROL D
 5      05     00000101     5     CONTROL E
 6      06     00000110     6     CONTROL F
 7      07     00000111     7     CONTROL G, rings bell
 8      08     00001000     8     CONTROL H
 9      09     00001001     9     CONTROL I
 10     0A     00001010     10    CONTROL J, line feed
 11     0B     00001011     11    CONTROL K
 12     0C     00001100     12    CONTROL L
 13     0D     00001101     13    CONTROL M, carriage return
 14     0E     00001110     14    CONTROL N
 15     0F     00001111     15    CONTROL O
 16     10     00010000     16    CONTROL P
 17     11     00010001     17    CONTROL Q
 18     12     00010010     18    CONTROL R
 19     13     00010011     19    CONTROL S
 20     14     00010100     20    CONTROL T
 21     15     00010101     21    CONTROL U
 22     16     00010110     22    CONTROL V
 23     17     00010111     23    CONTROL W
 24     18     00011000     24    CONTROL X
 25     19     00011001     25    CONTROL Y
 26     1A     00011010     26    CONTROL Z
 27     1B     00011011     27    CONTROL SHIFT K, ESCAPE
 28     1C     00011100     28    CONTROL SHIFT L
 29     1D     00011101     29    CONTROL SHIFT M
 30     1E     00011110     30    CONTROL SHIFT N
 31     1F     00011111     31    CONTROL SHIFT O
 32     20     00100000     32    SPACE
 33     21     00100001     33    !
 34     22     00100010     34    "
 35     23     00100011     35    #
 36     24     00100100     36    $
 37     25     00100101     37    %
 38     26     00100110     38    &amp;
 39     27     00100111     39    '
 40     28     00101000     40    (
 41     29     00101001     41    )
 42     2A     00101010     42    *
 43     2B     00101011     43    +
 44     2C     00101100     44    ,
 45     2D     00101101     45    -
 46     2E     00101110     46    .
 47     2F     00101111     47    /
 48     30     00110000     48    0
 49     31     00110001     49    1
 50     32     00110010     50    2
 51     33     00110011     51    3
 52     34     00110100     52    4
 53     35     00110101     53    5
 54     36     00110110     54    6
 55     37     00110111     55    7
 56     38     00111000     56    8
 57     39     00111001     57    9
 58     3A     00111010     58    :
 59     3B     00111011     59    ;
 60     3C     00111100     60    &lt;
 61     3D     00111101     61    =
 62     3E     00111110     62    &gt;
 63     3F     00111111     63    ?
 64     40     01000000     64    @
 65     41     01000001     65    A
 66     42     01000010     66    B
 67     43     01000011     67    C
 68     44     01000100     68    D
 69     45     01000101     69    E
 70     46     01000110     70    F
 71     47     01000111     71    G
 72     48     01001000     72    H
 73     49     01001001     73    I
 74     4A     01001010     74    J
 75     4B     01001011     75    K
 76     4C     01001100     76    L
 77     4D     01001101     77    M
 78     4E     01001110     78    N
 79     4F     01001111     79    O
 80     50     01010000     80    P
 81     51     01010001     81    Q
 82     52     01010010     82    R
 83     53     01010011     83    S
 84     54     01010100     84    T
 85     55     01010101     85    U
 86     56     01010110     86    V
 87     57     01010111     87    W
 88     58     01011000     88    X
 89     59     01011001     89    Y
 90     5A     01011010     90    Z
 91     5B     01011011     91    [
 92     5C     01011100     92    \
 93     5D     01011101     93    ]
 94     5E     01011110     94    ^
 95     5F     01011111     95    _
 96     60     01100000     96    `
 97     61     01100001     97    a
 98     62     01100010     98    b
 99     63     01100011     99    c
 100    64     01100100     100   d
 101    65     01100101     101   e
 102    66     01100110     102   f
 103    67     01100111     103   g
 104    68     01101000     104   h
 105    69     01101001     105   i
 106    6A     01101010     106   j
 107    6B     01101011     107   k
 108    6C     01101100     108   l
 109    6D     01101101     109   m
 110    6E     01101110     110   n
 111    6F     01101111     111   o
 112    70     01110000     112   p
 113    71     01110001     113   q
 114    72     01110010     114   r
 115    73     01110011     115   s
 116    74     01110100     116   t
 117    75     01110101     117   u
 118    76     01110110     118   v
 119    77     01110111     119   w
 120    78     01111000     120   x
 121    79     01111001     121   y
 122    7A     01111010     122   z
 123    7B     01111011     123   {
 124    7C     01111100     124   |
 125    7D     01111101     125   }
 126    7E     01111110     126   ~
 127    7F     01111111     127   DELETE
 128    80     10000000    -128
 129    81     10000001    -127
 130    82     10000010    -126
 131    83     10000011    -125
 132    84     10000100    -124
 133    85     10000101    -123
 134    86     10000110    -122
 135    87     10000111    -121
 136    88     10001000    -120
 137    89     10001001    -119
 138    8A     10001010    -118
 139    8B     10001011    -117
 140    8C     10001100    -116
 141    8D     10001101    -115
 142    8E     10001110    -114
 143    8F     10001111    -113
 144    90     10010000    -112
 145    91     10010001    -111
 146    92     10010010    -110
 147    93     10010011    -109
 148    94     10010100    -108
 149    95     10010101    -107
 150    96     10010110    -106
 151    97     10010111    -105
 152    98     10011000    -104
 153    99     10011001    -103
 154    9A     10011010    -102
 155    9B     10011011    -101
 156    9C     10011100    -100
 157    9D     10011101    -99
 158    9E     10011110    -98
 159    9F     10011111    -97
 160    A0     10100000    -96
 161    A1     10100001    -95
 162    A2     10100010    -94
 163    A3     10100011    -93
 164    A4     10100100    -92
 165    A5     10100101    -91
 166    A6     10100110    -90
 167    A7     10100111    -89
 168    A8     10101000    -88
 169    A9     10101001    -87
 170    AA     10101010    -86
 171    AB     10101011    -85
 172    AC     10101100    -84
 173    AD     10101101    -83
 174    AE     10101110    -82
 175    AF     10101111    -81
 176    B0     10110000    -80
 177    B1     10110001    -79
 178    B2     10110010    -78
 179    B3     10110011    -77
 180    B4     10110100    -76
 181    B5     10110101    -75
 182    B6     10110110    -74
 183    B7     10110111    -73
 184    B8     10111000    -72
 185    B9     10111001    -71
 186    BA     10111010    -70
 187    BB     10111011    -69
 188    BC     10111100    -68
 189    BD     10111101    -67
 190    BE     10111110    -66
 191    BF     10111111    -65
 192    C0     11000000    -64
 193    C1     11000001    -63
 194    C2     11000010    -62
 195    C3     11000011    -61
 196    C4     11000100    -60
 197    C5     11000101    -59
 198    C6     11000110    -58
 199    C7     11000111    -57
 200    C8     11001000    -56
 201    C9     11001001    -55
 202    CA     11001010    -54
 203    CB     11001011    -53
 204    CC     11001100    -52
 205    CD     11001101    -51
 206    CE     11001110    -50
 207    CF     11001111    -49
 208    D0     11010000    -48
 209    D1     11010001    -47
 210    D2     11010010    -46
 211    D3     11010011    -45
 212    D4     11010100    -44
 213    D5     11010101    -43
 214    D6     11010110    -42
 215    D7     11010111    -41
 216    D8     11011000    -40
 217    D9     11011001    -39
 218    DA     11011010    -38
 219    DB     11011011    -37
 220    DC     11011100    -36
 221    DD     11011101    -35
 222    DE     11011110    -34
 223    DF     11011111    -33
 224    E0     11100000    -32
 225    E1     11100001    -31
 226    E2     11100010    -30
 227    E3     11100011    -29
 228    E4     11100100    -28
 229    E5     11100101    -27
 230    E6     11100110    -26
 231    E7     11100111    -25
 232    E8     11101000    -24
 233    E9     11101001    -23
 234    EA     11101010    -22
 235    EB     11101011    -21
 236    EC     11101100    -20
 237    ED     11101101    -19
 238    EE     11101110    -18
 239    EF     11101111    -17
 240    F0     11110000    -16
 241    F1     11110001    -15
 242    F2     11110010    -14
 243    F3     11110011    -13
 244    F4     11110100    -12
 245    F5     11110101    -11
 246    F6     11110110    -10
 247    F7     11110111    -9
 248    F8     11111000    -8
 249    F9     11111001    -7
 250    FA     11111010    -6
 251    FB     11111011    -5
 252    FC     11111100    -4
 253    FD     11111101    -3
 254    FE     11111110    -2
 255    FF     11111111    -1</pre>



</body></html>